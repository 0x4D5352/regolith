{
package javascript

import (
    "fmt"

    "github.com/0x4d5352/regolith/internal/ast"
)

// parserState returns the parser state from the global state map
func parserState(c *current) *ast.ParserState {
    return c.globalStore["state"].(*ast.ParserState)
}
}

// Entry point - supports both /pattern/flags and plain pattern formats
Root <- SlashDelimited / PlainRegexp

// Slash-delimited format: /pattern/flags
SlashDelimited <- '/' regexp:Regexp '/' flags:Flags? EOF {
    r := regexp.(*ast.Regexp)
    if flags != nil {
        r.Flags = flags.(string)
    }
    return r, nil
}

// Plain pattern without delimiters
PlainRegexp <- regexp:Regexp EOF {
    return regexp.(*ast.Regexp), nil
}

// Flags at the end of a regex (dimgsuyv)
Flags <- [dimgsuyv]+ {
    text := string(c.text)
    hasU := false
    hasV := false
    for _, ch := range text {
        if ch == 'u' { hasU = true }
        if ch == 'v' { hasV = true }
    }
    if hasU && hasV {
        return nil, fmt.Errorf("flags 'u' and 'v' cannot be used together")
    }
    return text, nil
}

// Regexp is alternation of matches separated by |
Regexp <- first:Match rest:( '|' Match )* {
    matches := []*ast.Match{first.(*ast.Match)}
    if rest != nil {
        for _, r := range rest.([]any) {
            pair := r.([]any)
            matches = append(matches, pair[1].(*ast.Match))
        }
    }
    return &ast.Regexp{Matches: matches}, nil
}

// Match is a sequence of fragments
Match <- frags:MatchFragment* {
    fragments := []*ast.MatchFragment{}
    if frags != nil {
        for _, f := range frags.([]any) {
            fragments = append(fragments, f.(*ast.MatchFragment))
        }
    }
    return &ast.Match{Fragments: fragments}, nil
}

// MatchFragment is content with optional repeat
MatchFragment <- content:Content repeat:Repeat? {
    mf := &ast.MatchFragment{Content: content.(ast.Node)}
    if repeat != nil {
        mf.Repeat = repeat.(*ast.Repeat)
    }
    return mf, nil
}

// Content is what can appear in a match fragment
Content <- Anchor / Subexp / Charset / Terminal

// Anchor: ^ or $
Anchor <- ( '^' / '$' ) {
    anchorType := "start"
    if string(c.text) == "$" {
        anchorType = "end"
    }
    return &ast.Anchor{AnchorType: anchorType}, nil
}

// Subexp: groups with optional type marker
Subexp <- '(' groupType:GroupType? regexp:Regexp ')' {
    s := &ast.Subexp{Regexp: regexp.(*ast.Regexp)}
    if groupType != nil {
        switch gt := groupType.(type) {
        case string:
            // Simple group type (non_capture, lookahead, lookbehind)
            s.GroupType = gt
            s.Number = 0
        case map[string]any:
            // Named capture group
            s.GroupType = gt["type"].(string)
            s.Name = gt["name"].(string)
            s.Number = parserState(c).NextGroupNumber()
        }
    } else {
        s.GroupType = "capture"
        s.Number = parserState(c).NextGroupNumber()
    }
    return s, nil
}

// GroupType: (?:, (?=, (?!, (?<=, (?<!, (?<name>
// Note: lookbehind patterns (?<= and (?<!) must come before named groups (?<name>)
GroupType <- "?:" { return "non_capture", nil }
          / "?=" { return "positive_lookahead", nil }
          / "?!" { return "negative_lookahead", nil }
          / "?<=" { return "positive_lookbehind", nil }
          / "?<!" { return "negative_lookbehind", nil }
          / "?<" name:GroupName ">" {
              return map[string]any{"type": "named_capture", "name": name.(string)}, nil
          }

// GroupName: valid identifier for group names (letters, digits, underscore, starting with letter or underscore)
GroupName <- [a-zA-Z_][a-zA-Z0-9_]* {
    return string(c.text), nil
}

// Charset: [...] or [^...] â€” supports v-mode set operations (&&, --, nested)
Charset <- '[' inverted:'^'? expr:ClassExpression ']' {
    charset := &ast.Charset{
        Inverted: inverted != nil,
        Items:    []ast.CharsetItem{},
    }
    switch e := expr.(type) {
    case *ast.CharsetIntersection:
        charset.SetExpression = e
    case *ast.CharsetSubtraction:
        charset.SetExpression = e
    case []any:
        // Classic items from ClassUnion
        for _, item := range e {
            charset.Items = append(charset.Items, item.(ast.CharsetItem))
        }
    }
    return charset, nil
}

// ClassExpression: intersection, subtraction, or classic union
ClassExpression <- ClassIntersection / ClassSubtraction / ClassUnion

// ClassIntersection: operand && operand [&& operand]*
ClassIntersection <- first:ClassOperand rest:("&&" !'&' ClassOperand)+ {
    operands := []ast.Node{first.(ast.Node)}
    for _, r := range rest.([]any) {
        pair := r.([]any)
        operands = append(operands, pair[2].(ast.Node))
    }
    return &ast.CharsetIntersection{Operands: operands}, nil
}

// ClassSubtraction: operand -- operand [-- operand]*
ClassSubtraction <- first:ClassOperand rest:("--" !'-' ClassOperand)+ {
    operands := []ast.Node{first.(ast.Node)}
    for _, r := range rest.([]any) {
        pair := r.([]any)
        operands = append(operands, pair[2].(ast.Node))
    }
    return &ast.CharsetSubtraction{Operands: operands}, nil
}

// ClassUnion: classic list of items (0 or more)
ClassUnion <- items:ClassItem* {
    result := []any{}
    if items != nil {
        result = items.([]any)
    }
    return result, nil
}

// ClassOperand: something that can appear on either side of && or --
ClassOperand <- NestedCharset / StringDisjunction / UnicodePropertyEscapeInCharset / CharsetEscapeClass / ClassItemGroup

// NestedCharset: [...] inside a charset
NestedCharset <- '[' inverted:'^'? expr:ClassExpression ']' {
    charset := &ast.Charset{
        Inverted: inverted != nil,
        Items:    []ast.CharsetItem{},
    }
    switch e := expr.(type) {
    case *ast.CharsetIntersection:
        charset.SetExpression = e
    case *ast.CharsetSubtraction:
        charset.SetExpression = e
    case []any:
        for _, item := range e {
            charset.Items = append(charset.Items, item.(ast.CharsetItem))
        }
    }
    return charset, nil
}

// UnicodePropertyEscapeInCharset: \p{...} or \P{...} inside charset for use as operand
UnicodePropertyEscapeInCharset <- '\\' 'p' '{' prop:UnicodePropertyValue '}' {
    return &ast.UnicodePropertyEscape{Property: prop.(string), Negated: false}, nil
} / '\\' 'P' '{' prop:UnicodePropertyValue '}' {
    return &ast.UnicodePropertyEscape{Property: prop.(string), Negated: true}, nil
}

// CharsetEscapeClass: \d, \D, \w, \W, \s, \S as operand in set operations
CharsetEscapeClass <- '\\' code:[dDwWsS] {
    return makeEscape(string([]byte{code.([]byte)[0]})), nil
}

// ClassItemGroup: one or more classic items wrapped as a Charset operand
ClassItemGroup <- items:ClassItem+ {
    charset := &ast.Charset{Items: []ast.CharsetItem{}}
    for _, item := range items.([]any) {
        charset.Items = append(charset.Items, item.(ast.CharsetItem))
    }
    return charset, nil
}

// StringDisjunction: \q{abc|def} string disjunction (v-mode)
StringDisjunction <- "\\q{" first:ClassString rest:('|' ClassString)* '}' {
    strings := []string{first.(string)}
    if rest != nil {
        for _, r := range rest.([]any) {
            pair := r.([]any)
            strings = append(strings, pair[1].(string))
        }
    }
    return &ast.CharsetStringDisjunction{Strings: strings}, nil
}

// ClassString: a string within \q{...} (sequence of chars, no | or })
ClassString <- chars:ClassStringChar* {
    var result string
    if chars != nil {
        for _, ch := range chars.([]any) {
            result += ch.(string)
        }
    }
    return result, nil
}

// ClassStringChar: a single char in a class string (escape or literal, not | or })
ClassStringChar <- '\\' char:. {
    return string(char.([]byte)), nil
} / !'|' !'}' char:. {
    return string(c.text), nil
}

// ClassItem: individual item in a charset (range, nested charset, escape, literal)
ClassItem <- CharsetRange / NestedCharset / StringDisjunction / CharsetEscape / ClassLiteral

// CharsetRange: a-z
CharsetRange <- first:CharsetRangeBound '-' !'-' last:CharsetRangeBound {
    return &ast.CharsetRange{
        First: first.(string),
        Last:  last.(string),
    }, nil
}

// CharsetRangeBound: what can be a range endpoint
CharsetRangeBound <- CharsetRangeEscape / CharsetRangeLiteral

// CharsetRangeEscape: escaped char that can be a range bound
CharsetRangeEscape <- '\\' [bfnrtv] {
    return string(c.text), nil
} / '\\' 'x' [0-9a-fA-F] [0-9a-fA-F] {
    return string(c.text), nil
} / '\\' 'u' '{' [0-9a-fA-F]+ '}' {
    // Braced Unicode escape for range bound
    return string(c.text), nil
} / '\\' 'u' [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] {
    return string(c.text), nil
} / '\\' '0' [0-7]* {
    return string(c.text), nil
} / '\\' 'c' [a-zA-Z] {
    return string(c.text), nil
}

// CharsetRangeLiteral: literal char in a range context (not -, ], [, or \)
CharsetRangeLiteral <- !'[' [^-\]\\] {
    return string(c.text), nil
} / '\\' . {
    return string(c.text), nil
}

// CharsetEscape: escape sequence in charset
CharsetEscape <- '\\' code:[bdDfnrsStvwW] {
    return makeEscape(string([]byte{code.([]byte)[0]})), nil
} / UnicodePropertyEscapeInCharset
  / '\\' 'x' [0-9a-fA-F] [0-9a-fA-F] {
    return &ast.Escape{EscapeType: "hex", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' 'u' '{' [0-9a-fA-F]+ '}' {
    // Braced Unicode escape \u{HHHHHH} for code points beyond BMP
    return &ast.Escape{EscapeType: "unicode_braced", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' 'u' [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] {
    return &ast.Escape{EscapeType: "unicode", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' '0' [0-7]* {
    return &ast.Escape{EscapeType: "octal", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' 'c' [a-zA-Z] {
    return &ast.Escape{EscapeType: "control", Code: string(c.text), Value: string(c.text)}, nil
}

// ClassLiteral: literal character in charset - excludes ], [, \, and operators
ClassLiteral <- !"&&" !"--" !"[" [^\]\\] {
    return &ast.CharsetLiteral{Text: string(c.text)}, nil
} / '\\' char:. {
    return &ast.CharsetLiteral{Text: string(char.([]byte))}, nil
}

// Terminal: what can appear outside groups/charsets
Terminal <- AnyChar / Escape / Literal

// AnyChar: the . metacharacter
AnyChar <- '.' {
    return &ast.AnyCharacter{}, nil
}

// Escape: escape sequences
Escape <- '\\' code:[bBdDfnrsStvwW] {
    return makeEscape(string([]byte{code.([]byte)[0]})), nil
} / '\\' 'p' '{' prop:UnicodePropertyValue '}' {
    // Unicode property escape \p{...}
    return &ast.UnicodePropertyEscape{Property: prop.(string), Negated: false}, nil
} / '\\' 'P' '{' prop:UnicodePropertyValue '}' {
    // Negated Unicode property escape \P{...}
    return &ast.UnicodePropertyEscape{Property: prop.(string), Negated: true}, nil
} / '\\' 'k' '<' name:GroupName '>' {
    // Named backreference \k<name>
    return &ast.BackReference{Name: name.(string)}, nil
} / '\\' code:[1-9] {
    num := int(code.([]byte)[0] - '0')
    return &ast.BackReference{Number: num}, nil
} / '\\' 'x' [0-9a-fA-F] [0-9a-fA-F] {
    return &ast.Escape{EscapeType: "hex", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' 'u' '{' [0-9a-fA-F]+ '}' {
    // Braced Unicode escape \u{HHHHHH} for code points beyond BMP
    return &ast.Escape{EscapeType: "unicode_braced", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' 'u' [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] {
    return &ast.Escape{EscapeType: "unicode", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' '0' [0-7]* {
    return &ast.Escape{EscapeType: "octal", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' 'c' [a-zA-Z] {
    return &ast.Escape{EscapeType: "control", Code: string(c.text), Value: string(c.text)}, nil
}

// UnicodePropertyValue: property name like "Letter", "L", "Script=Greek"
UnicodePropertyValue <- [a-zA-Z0-9_=]+ {
    return string(c.text), nil
}

// Literal: regular characters (not metacharacters)
Literal <- LiteralChars+ {
    return &ast.Literal{Text: string(c.text)}, nil
} / '\\' char:. {
    // Escaped character becomes literal
    return &ast.Literal{Text: string(char.([]byte))}, nil
}

// LiteralChars: characters that don't need escaping in a regex
// Note: / is excluded so /pattern/flags format works
LiteralChars <- [a-zA-Z0-9_ !@#%&:;"'<>,`~=-]

// Repeat: quantifiers
Repeat <- spec:RepeatSpec greedy:'?'? {
    r := spec.(*ast.Repeat)
    r.Greedy = greedy == nil
    return r, nil
}

// RepeatSpec: the quantifier itself
RepeatSpec <- '*' {
    return &ast.Repeat{Min: 0, Max: -1, Greedy: true}, nil
} / '+' {
    return &ast.Repeat{Min: 1, Max: -1, Greedy: true}, nil
} / '?' {
    return &ast.Repeat{Min: 0, Max: 1, Greedy: true}, nil
} / '{' min:[0-9]+ ',' max:[0-9]+ '}' {
    minVal := parseInt(min)
    maxVal := parseInt(max)
    return &ast.Repeat{Min: minVal, Max: maxVal, Greedy: true}, nil
} / '{' min:[0-9]+ ',' '}' {
    minVal := parseInt(min)
    return &ast.Repeat{Min: minVal, Max: -1, Greedy: true}, nil
} / '{' exact:[0-9]+ '}' {
    val := parseInt(exact)
    return &ast.Repeat{Min: val, Max: val, Greedy: true}, nil
}

EOF <- !.
