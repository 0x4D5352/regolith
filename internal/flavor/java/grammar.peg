{
package java

import "github.com/0x4d5352/regolith/internal/ast"

// parserState returns the parser state from the global state map
func parserState(c *current) *ast.ParserState {
    return c.globalStore["state"].(*ast.ParserState)
}
}

// Entry point - Java patterns are plain strings (no /pattern/flags format)
Root <- regexp:Regexp EOF {
    return regexp.(*ast.Regexp), nil
}

// Regexp is alternation of matches separated by |
Regexp <- first:Match rest:( '|' Match )* {
    matches := []*ast.Match{first.(*ast.Match)}
    if rest != nil {
        for _, r := range rest.([]any) {
            pair := r.([]any)
            matches = append(matches, pair[1].(*ast.Match))
        }
    }
    return &ast.Regexp{Matches: matches}, nil
}

// Match is a sequence of fragments
Match <- frags:MatchFragment* {
    fragments := []*ast.MatchFragment{}
    if frags != nil {
        for _, f := range frags.([]any) {
            fragments = append(fragments, f.(*ast.MatchFragment))
        }
    }
    return &ast.Match{Fragments: fragments}, nil
}

// MatchFragment is content with optional repeat
MatchFragment <- content:Content repeat:Repeat? {
    mf := &ast.MatchFragment{Content: content.(ast.Node)}
    if repeat != nil {
        mf.Repeat = repeat.(*ast.Repeat)
    }
    return mf, nil
}

// Content is what can appear in a match fragment
// Note: Comment and InlineModifier must come before Subexp since they start with (?
Content <- Anchor / Comment / InlineModifier / Subexp / Charset / Terminal

// Comment: (?#...) - inline comment, matches nothing
Comment <- "(?#" text:CommentText ')' {
    return &ast.Comment{Text: text.(string)}, nil
}

// InlineModifier: (?flags), (?-flags), (?flags-flags), or scoped (?flags:X)
// Java flags: i, d, m, s, u, x, U
InlineModifier <- "(?" enable:Flags? '-' disable:Flags ':' regexp:Regexp ')' {
    // Scoped modifier with both enable and disable: (?i-m:X)
    enableStr := ""
    if enable != nil {
        enableStr = enable.(string)
    }
    return &ast.InlineModifier{
        Enable:  enableStr,
        Disable: disable.(string),
        Regexp:  regexp.(*ast.Regexp),
    }, nil
} / "(?" enable:Flags ':' regexp:Regexp ')' {
    // Scoped modifier with enable only: (?i:X)
    return &ast.InlineModifier{
        Enable: enable.(string),
        Regexp: regexp.(*ast.Regexp),
    }, nil
} / "(?" enable:Flags? '-' disable:Flags ')' {
    // Global modifier with both enable and disable: (?i-m) or (?-m)
    enableStr := ""
    if enable != nil {
        enableStr = enable.(string)
    }
    return &ast.InlineModifier{
        Enable:  enableStr,
        Disable: disable.(string),
    }, nil
} / "(?" enable:Flags ')' {
    // Global modifier with enable only: (?i)
    return &ast.InlineModifier{
        Enable: enable.(string),
    }, nil
}

// Flags: one or more Java regex flags
Flags <- [idmsuxU]+ {
    return string(c.text), nil
}

// CommentText: everything until the closing )
CommentText <- [^)]* {
    return string(c.text), nil
}

// Anchor: ^ or $
Anchor <- ( '^' / '$' ) {
    anchorType := "start"
    if string(c.text) == "$" {
        anchorType = "end"
    }
    return &ast.Anchor{AnchorType: anchorType}, nil
}

// Subexp: groups with optional type marker
// Java supports: (), (?:), (?=), (?!), (?<=), (?<!), (?<name>), (?>)
Subexp <- '(' groupType:GroupType? regexp:Regexp ')' {
    s := &ast.Subexp{Regexp: regexp.(*ast.Regexp)}
    if groupType != nil {
        switch gt := groupType.(type) {
        case string:
            // Simple group type (non_capture, lookahead, lookbehind, atomic)
            s.GroupType = gt
            s.Number = 0
        case map[string]any:
            // Named capture group
            s.GroupType = gt["type"].(string)
            s.Name = gt["name"].(string)
            s.Number = parserState(c).NextGroupNumber()
        }
    } else {
        s.GroupType = "capture"
        s.Number = parserState(c).NextGroupNumber()
    }
    return s, nil
}

// GroupType: (?:, (?=, (?!, (?<=, (?<!, (?<name>, (?>
// Note: lookbehind patterns (?<= and (?<!) must come before named groups (?<name>)
// Note: (?> must come before other group types
GroupType <- "?>" { return "atomic", nil }
          / "?:" { return "non_capture", nil }
          / "?=" { return "positive_lookahead", nil }
          / "?!" { return "negative_lookahead", nil }
          / "?<=" { return "positive_lookbehind", nil }
          / "?<!" { return "negative_lookbehind", nil }
          / "?<" name:GroupName ">" {
              return map[string]any{"type": "named_capture", "name": name.(string)}, nil
          }

// GroupName: valid identifier for group names (letters only at start, then letters/digits)
// Java group names: first char must be letter, subsequent can be letter or digit
GroupName <- [a-zA-Z][a-zA-Z0-9]* {
    return string(c.text), nil
}

// Charset: [...] or [^...]
Charset <- '[' inverted:'^'? items:CharsetItem* ']' {
    charset := &ast.Charset{
        Inverted: inverted != nil,
        Items:    []ast.CharsetItem{},
    }
    if items != nil {
        for _, item := range items.([]any) {
            charset.Items = append(charset.Items, item.(ast.CharsetItem))
        }
    }
    return charset, nil
}

// CharsetItem: range or single character/escape
CharsetItem <- CharsetRange / CharsetEscape / CharsetLiteral

// CharsetRange: a-z
CharsetRange <- first:CharsetRangeBound '-' last:CharsetRangeBound {
    return &ast.CharsetRange{
        First: first.(string),
        Last:  last.(string),
    }, nil
}

// CharsetRangeBound: what can be a range endpoint
CharsetRangeBound <- CharsetRangeEscape / CharsetRangeLiteral

// CharsetRangeEscape: escaped char that can be a range bound
CharsetRangeEscape <- '\\' [bfnrtaev] {
    return string(c.text), nil
} / '\\' 'x' [0-9a-fA-F] [0-9a-fA-F] {
    return string(c.text), nil
} / '\\' 'x' '{' [0-9a-fA-F]+ '}' {
    // Java extended hex escape \x{h...h}
    return string(c.text), nil
} / '\\' 'u' [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] {
    return string(c.text), nil
} / '\\' '0' [0-7]* {
    return string(c.text), nil
} / '\\' 'c' [a-zA-Z] {
    return string(c.text), nil
}

// CharsetRangeLiteral: literal char in a range context (not - or ] or \)
CharsetRangeLiteral <- [^-\]\\] {
    return string(c.text), nil
} / '\\' . {
    return string(c.text), nil
}

// CharsetEscape: escape sequence in charset
// Java supports: \d \D \w \W \s \S \h \H \v \V (and standard control chars)
CharsetEscape <- '\\' code:[bdDhHsSwWvV] {
    return makeEscape(string([]byte{code.([]byte)[0]})), nil
} / '\\' code:[fnrtae] {
    return makeEscape(string([]byte{code.([]byte)[0]})), nil
} / '\\' 'x' [0-9a-fA-F] [0-9a-fA-F] {
    return &ast.Escape{EscapeType: "hex", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' 'x' '{' [0-9a-fA-F]+ '}' {
    // Java extended hex escape \x{h...h}
    return &ast.Escape{EscapeType: "hex_extended", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' 'u' [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] {
    return &ast.Escape{EscapeType: "unicode", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' '0' [0-7]* {
    return &ast.Escape{EscapeType: "octal", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' 'c' [a-zA-Z] {
    return &ast.Escape{EscapeType: "control", Code: string(c.text), Value: string(c.text)}, nil
}

// CharsetLiteral: literal character in charset (not ] or \)
CharsetLiteral <- [^\]\\] {
    return &ast.CharsetLiteral{Text: string(c.text)}, nil
} / '\\' char:. {
    return &ast.CharsetLiteral{Text: string(char.([]byte))}, nil
}

// Terminal: what can appear outside groups/charsets
// QuotedLiteral must come before Escape to match \Q...\E
Terminal <- AnyChar / QuotedLiteral / Escape / Literal

// QuotedLiteral: \Q...\E - treat everything between as literal text
QuotedLiteral <- "\\Q" text:QuotedText "\\E" {
    return &ast.QuotedLiteral{Text: text.(string)}, nil
}

// QuotedText: everything until \E (greedy but stops at \E)
QuotedText <- ( !("\\E") . )* {
    return string(c.text), nil
}

// AnyChar: the . metacharacter
AnyChar <- '.' {
    return &ast.AnyCharacter{}, nil
}

// Escape: escape sequences
// Java-specific: \a, \e (control chars), \h \H \v \V (whitespace classes), \R \X (matchers)
// Anchors: \b \B \A \Z \z \G
Escape <- '\\' code:[bBAZzG] {
    return makeAnchor(string([]byte{code.([]byte)[0]})), nil
} / '\\' code:[dDwWsShHvVRX] {
    return makeEscape(string([]byte{code.([]byte)[0]})), nil
} / '\\' code:[fnrtae] {
    return makeEscape(string([]byte{code.([]byte)[0]})), nil
} / '\\' 'p' '{' prop:UnicodePropertyValue '}' {
    // Unicode property escape \p{...}
    return &ast.UnicodePropertyEscape{Property: prop.(string), Negated: false}, nil
} / '\\' 'P' '{' prop:UnicodePropertyValue '}' {
    // Negated Unicode property escape \P{...}
    return &ast.UnicodePropertyEscape{Property: prop.(string), Negated: true}, nil
} / '\\' 'k' '<' name:GroupName '>' {
    // Named backreference \k<name>
    return &ast.BackReference{Name: name.(string)}, nil
} / '\\' code:[1-9] rest:[0-9]* {
    // Back-reference \1 through \99 (or higher if groups exist)
    numStr := string(code.([]byte)) + getString(rest)
    num := parseInt(numStr)
    return &ast.BackReference{Number: num}, nil
} / '\\' 'x' [0-9a-fA-F] [0-9a-fA-F] {
    return &ast.Escape{EscapeType: "hex", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' 'x' '{' [0-9a-fA-F]+ '}' {
    // Java extended hex escape \x{h...h}
    return &ast.Escape{EscapeType: "hex_extended", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' 'u' [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] {
    return &ast.Escape{EscapeType: "unicode", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' '0' [0-7]* {
    return &ast.Escape{EscapeType: "octal", Code: string(c.text), Value: string(c.text)}, nil
} / '\\' 'c' [a-zA-Z] {
    return &ast.Escape{EscapeType: "control", Code: string(c.text), Value: string(c.text)}, nil
}

// UnicodePropertyValue: property name like "L", "Lu", "IsLatin", "InGreek", "script=Hiragana"
// Java supports: Category codes (L, Lu), Script names (IsLatin), Block names (InGreek),
// POSIX-style (Lower, Upper, ASCII), Java-specific (javaLowerCase)
UnicodePropertyValue <- [a-zA-Z0-9_=]+ {
    return string(c.text), nil
}

// Literal: regular characters (not metacharacters)
Literal <- LiteralChars+ {
    return &ast.Literal{Text: string(c.text)}, nil
} / '\\' char:. {
    // Escaped character becomes literal
    return &ast.Literal{Text: string(char.([]byte))}, nil
}

// LiteralChars: characters that don't need escaping in a regex
// Note: Java doesn't use /pattern/ format, so / is a literal char
LiteralChars <- [a-zA-Z0-9_ !@#%&:;"'<>,`~=/-]

// Repeat: quantifiers (greedy, non-greedy, possessive)
// Java supports possessive quantifiers: *+, ++, ?+, {n}+
Repeat <- spec:RepeatSpec modifier:RepeatModifier? {
    r := spec.(*ast.Repeat)
    if modifier != nil {
        switch modifier.(string) {
        case "?":
            r.Greedy = false
        case "+":
            r.Possessive = true
        }
    }
    return r, nil
}

// RepeatModifier: ? for non-greedy, + for possessive
RepeatModifier <- ( '?' / '+' ) {
    return string(c.text), nil
}

// RepeatSpec: the quantifier itself
RepeatSpec <- '*' {
    return &ast.Repeat{Min: 0, Max: -1, Greedy: true}, nil
} / '+' {
    return &ast.Repeat{Min: 1, Max: -1, Greedy: true}, nil
} / '?' {
    return &ast.Repeat{Min: 0, Max: 1, Greedy: true}, nil
} / '{' min:[0-9]+ ',' max:[0-9]+ '}' {
    minVal := parseInt(min)
    maxVal := parseInt(max)
    return &ast.Repeat{Min: minVal, Max: maxVal, Greedy: true}, nil
} / '{' min:[0-9]+ ',' '}' {
    minVal := parseInt(min)
    return &ast.Repeat{Min: minVal, Max: -1, Greedy: true}, nil
} / '{' exact:[0-9]+ '}' {
    val := parseInt(exact)
    return &ast.Repeat{Min: val, Max: val, Greedy: true}, nil
}

EOF <- !.
