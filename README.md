# regolith

A command-line tool for visualizing regular expressions as SVG railroad diagrams.

![Go Version](https://img.shields.io/badge/Go-1.25+-00ADD8?style=flat&logo=go)

## Acknowledgements

regolith began as a fork of [regexper.com](https://regexper.com/) by [Jeff Avallone](https://github.com/javallone).
The railroad diagram visual style, layout approach, and rendering concepts owe a great deal to that project.
regolith has since been rewritten in Go and expanded to support multiple regex flavors beyond JavaScript.

## AI Use Statement

All code in this repository has been generated by Anthropic Claude via Claude Code,
specifically Claude Opus 4.5 and 4.6, as part of an exercise in understanding the
capabilities, cost, and limitations of Large Language Models. I take no credit for 
any code associated with a commit that contains the `[claude]` flag in the description.

A `codex` branch will contain an alternative version of this repository built from
the same starting point as this one utilizing OpenAI Codex as a comparison for any
interested party.

## Features

- Visualize regex patterns as clean SVG railroad diagrams
- **8 regex flavors** with dedicated PEG grammars:
  - **JavaScript** (ECMAScript 2018+) - including `v` flag unicode sets
  - **Java** (`java.util.regex.Pattern`)
  - **.NET** (`System.Text.RegularExpressions`)
  - **PCRE** (PCRE2) - the most feature-rich flavor
  - **POSIX BRE** (IEEE Std 1003.1)
  - **POSIX ERE** (IEEE Std 1003.1)
  - **GNU grep BRE** (BRE with GNU extensions)
  - **GNU grep ERE** (ERE with GNU extensions, like `grep -E`)
- Customizable colors and dimensions
- String literal unescaping for Java/.NET patterns copied from source code

## Installation

### From Source

```bash
go install github.com/0x4d5352/regolith/cmd/regolith@latest
```

### Build from Repository

```bash
git clone https://github.com/0x4d5352/regolith.git
cd regolith
make build
```

## Usage

### Basic Usage

```bash
# Visualize a regex pattern (defaults to JavaScript flavor)
regolith 'a|b|c'

# Specify output file
regolith -o output.svg '[a-z]+'

# Read pattern from stdin
echo '^hello$' | regolith
```

### Selecting a Flavor

```bash
# JavaScript (default) - supports /pattern/flags syntax
regolith -flavor javascript '/pattern/gi'

# Java
regolith -flavor java '(?i)\p{Alpha}+\d{2,}'

# .NET - balanced groups, variable-length lookbehind
regolith -flavor dotnet '(?<open>\().*?(?<close-open>\))'

# PCRE - recursive patterns, callouts, backtracking control
regolith -flavor pcre '(?R)|(?C1)\b\w+\b(*SKIP)(*FAIL)'

# POSIX BRE - uses \( \) for groups
regolith -flavor posix-bre '\([[:alpha:]]\{2,\}\)'

# POSIX ERE
regolith -flavor posix-ere '([[:alpha:]]{2,})'

# GNU grep BRE (also available as just "gnugrep")
regolith -flavor gnugrep-bre '\bword\b'

# GNU grep ERE
regolith -flavor gnugrep-ere '\b[[:digit:]]+\b'
```

### String Literal Unescaping

When copying regex patterns from Java or .NET source code, backslashes are doubled. Use `-unescape` to handle this:

```bash
# Pattern from Java source: "\\d+\\.\\d+"
regolith -flavor java -unescape '\\d+\\.\\d+'
```

### Customization

#### Colors

```bash
regolith -literal-fill '#ff6b6b' -escape-fill '#4ecdc4' 'hello\d+'
```

Available color flags:
- `-text-color` - Text color (default: `#000`)
- `-line-color` - Line/stroke color (default: `#000`)
- `-literal-fill` - Literal box fill (default: `#ff6b6b`)
- `-charset-fill` - Character set fill (default: `#cbcbba`)
- `-escape-fill` - Escape sequence fill (default: `#bada55`)
- `-anchor-fill` - Anchor box fill (default: `#6b6659`)
- `-subexp-fill` - Outermost subexpression fill (default: `none`; nested groups cycle through distinct colors)

#### Dimensions

```bash
regolith -padding 20 -font-size 16 -line-width 3 'pattern'
```

Available dimension flags:
- `-padding` - Padding around diagram (default: `10`)
- `-font-size` - Font size in pixels (default: `14`)
- `-line-width` - Stroke width for lines (default: `2`)

## Supported Features by Flavor

| Feature | JS | Java | .NET | PCRE | POSIX BRE | POSIX ERE | GNU BRE | GNU ERE |
|---------|----|------|------|------|-----------|-----------|---------|---------|
| Literals & alternation | x | x | x | x | x | x | x | x |
| Character classes | x | x | x | x | x | x | x | x |
| POSIX classes (`[:alpha:]`) | | x | | x | x | x | x | x |
| Quantifiers (`*+?{n,m}`) | x | x | x | x | x | x | x | x |
| Non-greedy quantifiers | x | x | x | x | | | | |
| Possessive quantifiers | | x | x | x | | | | |
| Capture groups | x | x | x | x | x | x | x | x |
| Named groups | x | x | x | x | | | | |
| Non-capture groups | x | x | x | x | | x | | x |
| Lookahead | x | x | x | x | | | | |
| Lookbehind | x | x | x | x | | | | |
| Variable-length lookbehind | | | x | | | | | |
| Atomic groups | | x | x | x | | | | |
| Back-references | x | x | x | x | x | | x | x |
| Unicode properties (`\p{}`) | x | x | x | x | | | | |
| Unicode sets (v-flag) | x | | | | | | | |
| Inline modifiers (`(?i)`) | | x | x | x | | | | |
| Comments (`(?#...)`) | | x | x | x | | | | |
| Conditional patterns | | | x | x | | | | |
| Recursive patterns | | | | x | | | | |
| Balanced groups | | | x | | | | | |
| Branch reset (`(?\|...)`) | | | | x | | | | |
| Backtracking control | | | | x | | | | |
| Callouts | | | | x | | | | |
| Script runs | | | | x | | | | |
| `\Q...\E` quoted literals | | x | x | x | | | | |

## Development

### Prerequisites

- Go 1.25 or later
- [pigeon](https://github.com/mna/pigeon) for parser generation (installed automatically by `make generate`)

### Building and Testing

```bash
make build                # Build for current platform
make test                 # Run all tests
make coverage             # Test with coverage report
make lint                 # Run linter (requires golangci-lint)
make fmt                  # Format code
```

### Parser Generation

Each flavor has a PEG grammar (`grammar.peg`) that is compiled into a Go parser. After modifying any grammar file:

```bash
make generate             # Regenerate ALL flavor parsers
make generate-javascript  # Regenerate a single flavor's parser
```

Do **not** edit `parser.go` files directly - they are auto-generated.

### Updating Golden Tests

When intentionally changing SVG output:

```bash
make golden
# or equivalently:
GOLDEN_UPDATE=1 go test ./internal/renderer/...
```

### Project Structure

```
regolith/
├── cmd/regolith/              # CLI entry point
├── internal/
│   ├── ast/                   # Shared AST node types
│   │   └── ast.go
│   ├── flavor/                # Flavor interface and registry
│   │   ├── flavor.go
│   │   ├── javascript/        # Each flavor has its own package:
│   │   │   ├── grammar.peg    #   PEG grammar definition
│   │   │   ├── parser.go      #   Generated parser (do not edit)
│   │   │   ├── flavor.go      #   Flavor registration
│   │   │   ├── helpers.go     #   Parser action helpers
│   │   │   └── flavor_test.go #   Parser tests
│   │   ├── java/
│   │   ├── dotnet/
│   │   ├── pcre/
│   │   ├── posix_bre/
│   │   ├── posix_ere/
│   │   ├── gnugrep_bre/
│   │   └── gnugrep_ere/
│   ├── renderer/              # SVG rendering
│   │   ├── renderer.go        #   AST-to-SVG dispatch
│   │   ├── svg.go             #   SVG element types
│   │   ├── layout.go          #   Bounding box and positioning
│   │   ├── styles.go          #   Color/dimension configuration
│   │   └── testdata/golden/   #   Golden test SVGs per flavor
│   ├── parser/                # Legacy shim (delegates to JS flavor)
│   └── unescape/              # String literal unescaping
└── README.md
```

## Architecture

regolith uses a parse-then-render pipeline: **PEG grammar -> AST -> SVG**.

1. Each regex flavor defines a PEG grammar that produces a shared AST
2. Flavors register themselves via `init()` and are discovered through a central registry
3. The renderer walks the AST and produces SVG elements with bounding box calculations
4. Layout uses anchor points to connect elements with railroad-style paths

## License

MIT License - see [LICENSE](LICENSE) for details.
